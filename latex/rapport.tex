\documentclass[12pt]{report}

%% Language and font encodings
\usepackage[francais]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern} 
\usepackage[svgnames]{xcolor}
\usepackage{float} % figure
\usepackage{eurosym} % euro character
\usepackage{minted} % syntax coloring

%% Sets page size and margins
\usepackage[a4paper,top=3cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

%% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}

\title{Projet Licence ADSILLH 2017/2018\\Rapport}
\author{Gautier DELACOUR\\Pierre-Antoine ROUBY\\David TABARIE} % PA: TODO add GNOME-Music

\begin{document}
\maketitle

\begin{abstract}
Ce document présente les différents contributions effectués dans le cadre du projet sous licence libre de la licence ADSILLH.

\end{abstract}

\tableofcontents

\chapter{Introduction}

\section{La Licence ADSILLH}
% from: http://dept-info.labri.fr/ENSEIGNEMENT/adsillh/contenu.html
L'objectif est de former des techniciens en informatique de haut
niveau en administration des systèmes d'information, polyvalents et
aptes à effectuer l'intégration de composants logiciels libres
appartenant à de nombreux domaines fonctionnels:

systèmes d'exploitation
bases de données
serveurs web
téléphonie logicielle

alliant ainsi de solides compétences d'administration à des capacités
de développement, en partant des couches les plus basses jusqu'aux
plus hautes, et l'aptitude à intégrer ces développements au sein des
communautés libres. Ce profil est explicitement recherché par les
entreprises et fait l'unicité de la formation. Il est couramment
appelé « DevOps Engineer ».

La formation apporte également des aspects organisationnels en droit
et en économie des logiciels libres.

\section{Le projet}
Le but du projet est avant tout de nous accoutumer au développement
collaboratif, et de nous apprendre à intéragir avec une communauté
du logiciel libre.

\chapter{Le projet GNOME}
% from: https://fr.wikipedia.org/wiki/GNOME
GNOME, acronyme de GNU Network Object Model Environment, est un
environnement de bureau libre convivial dont l'objectif est de rendre
accessible l'utilisation du système d'exploitation GNU au plus grand
nombre ; cette interface est actuellement populaire sur les systèmes
GNU/Linux et fonctionne également sur la plupart des systèmes de type
UNIX.

GNOME est développé par The GNOME Project dont les participants sont
bénévoles ou rémunérés par des entreprises externes au projet. La
majorité du travail est fournie par les contributeurs professionnels,
en premier lieu ceux travaillant pour Red Hat.

\section{Les outils collaboratifs} 
% TODO PA: Cette partie a besion d'une relecture ;)
\subsection{Bugzilla}
\label{bugzilla}
% from: https://fr.wikipedia.org/wiki/Bugzilla
Bugzilla est une solution de gestion de bug, distribuée sous
% form: https://fr.wikipedia.org/wiki/Double_licence
tri-licence\footnote{Tri-licence: Le concept de licence multiple
  est de proposer un travail non pas sous une licence unique, mais
  en offrant un choix restreint de licence, pour permettre une plus
  grande flexibilité. (source:
  \href{https://fr.wikipedia.org/wiki/Licence_multiple}{Wikipedia})}
MPL\footnote{MPL: Mozilla Public License (source:
  \href{https://www.mozilla.org/en-US/MPL/}{Mozilla})}
/ GNU GPL\footnote{GNU GPL: GNU General Public License (source:
  \href{https://www.gnu.org/licenses/gpl.html}{Gnu})}
/ GNU LGPL\footnote{GNU LGPL: GNU Lesser General Public License (source:
  \href{https://www.gnu.org/licenses/lgpl.html}{Gnu})}
, elle est developpée et utilisée à l'origine par Mozilla.
GNOME a mis en place un \href{https://bugzilla.gnome.org}{bugzilla} pour 
la gestion des bugs dans les différents projets.
%% (figure~\ref{figure_bugzilla} page~\pageref{figure_bugzilla})
\newline
% from: https://bugzilla.gnome.org/page.cgi?id=points.html
Bugzilla intègre aussi une fonctionnalité de "score"
%% (figure~\ref{figure_bugzilla_score} page~\pageref{figure_bugzilla_score})
, dont le but est a l'origine d'avoir une idée 
aproximative de l'activité d'une personne  sur le bugzilla, et donc 
des personnes qui sont le plus experimenté pour aidée les autres 
utilisateurs. Mais ce dispositif s'est revelé peu efficace. Le
score est donc plus une fonctionnalite un peut fun qu'un vrai outils.
A noter qu'il existe quand même un classement de la semaine, disponible 
\href{https://bugzilla.gnome.org/page.cgi?id=weekly-bug-summary.html}{ici}.

\subsection{Wiki}
\label{wiki}
GNOME dispose d'un \href{https://wiki.gnome.org/}{wiki} où l'on peut retrouver 
les documentations sur les différents projets.
%% (figure~\ref{figure_wiki} page~\pageref{figure_wiki}).

\subsection{Git}
\label{git}

\label{cgit}
Le projet GNOME dispose de plusieurs interfaces Git. L'interface 
principale est basée sur le logiciel libre "cgit"
%% (figure~\ref{figure_cgit} page~\pageref{figure_cgit})
, on peut y retrouver la plupare des projets GNOME 
(\href{https://git.gnome.org/}{ici}). Pour créer un bug il faut passer par Bugzilla
(section~\ref{bugzilla}).

\label{gitlab}
GNOME a aussi mis en place un \href{https://gitlab.gnome.org/GNOME}{GitLab} 
ou l'on peut trouver de nombreux projet. L'interface est plus moderne,
par exemple nous pouvons créer des "Pull Requests" comme sur github
et le report de bug est sur l'interface gitlab, donc pas besoin de passer
par le Bugzilla. Il est aussi possible de parcourire le code via l'interface
web de gitlab.
%% (figure~\ref{figure_gitlab} page~\pageref{figure_gitlab}).

\label{github}
Il existe aussi un mirroir des repertoires git des projets 
\href{https://github.com/GNOME}{GNOME sur GitHub}.

\subsection{IRC}
Le projet GNOME dispose aussi d'un chat irc (\href{irc.gnome.org}{irc.gnome.org})
avec de nombreux channel, dont voici quelque examples :
\begin{itemize}
\item \#gnome-hacker : Pour les dicutions sur le développement de GNOME
\item \#newcomers : Fait pour les nouveaux contributeur au projet
\item \#gnome-games : Pour les discutions autour du projet GNOME-Games
\item \#vala : Spésifique pour le language vala
\end{itemize}

\subsection{Newcomers}
% PA: TODO /!\ Partie importante !

\newpage
\chapter{GNOME-Music}
%% TODO GNOME-Music %%
% David: Fuck them !

\newpage
\chapter{GNOME Games}
GNOME Games est une application permettant la gestion d'une
bibliothèque vidéoludique. Elle est capable de s'interfacer avec de
nombreux émulateurs.
Au debut du projet Games étais disponible sur le git de GNOME, mais 
depuis peut il a été migré sur le gitlab du projet GNOME.

\section{Architecture du projet}
\subsection{Les projets assosié}
Le projet s'appuie sur plusieur autre projets:
\begin{itemize}
\item retro-gtk : Développé pas le mainteneur de Games et utilisant les bibliotheques libretro,
retro-gtk permet à Games de lancer les jeux retro.
\item libmanette : Libmannette et aussi développé pas le mainteneur de Games. Cette bibliotheque
permet la gestion des manettes.
% TODO Verifier les info pour libmanette et retro-gtk 
\end{itemize}

% PA: On garde sa ?
% David: What is it ?
% TODO Sondage
%          Oui | Non
% David:     x | x
% Gautier:     |
% PA:          | X
%----------------------
% result:   0  | 1
\subsection{Les sources}
Structure des sources du projet:
\begin{itemize}
\item data : contient toutes les données graphiques de l'application.
\item flatpak : contient tous les fichiers nécessaires à l'exécution de Flatpack.
\item plugins
\begin{itemize}
\item desktop : contient les fichiers s'occupant de la gestion du bureau.
\item dreamcast, game-cube, playstation... :  contient les fichiers gérant l'émulation des différentes consoles.
\end{itemize}
\item po
\item src
\begin{itemize}
\item command
\item core
\item database
\item dummy
\item event
\item gameinfo
\item gamepad
\item generic
\item grilo
\item retro
\item tracker
\item ui : contient les fichiers qui gèrent l'interface graphique.
\item utils
\end{itemize}
\item tools
\end{itemize}

\section{Le langage Vala}
% from: https://fr.wikipedia.org/wiki/Vala_(langage)
Vala est un langage de programmation compilé, dont l'objectif est de
fournir les bénéfices des langages de programmation modernes (comme la
POO) aux développeurs de la plateforme GNOME qui utilisent GLib et son
système GObject.

Sa syntaxe est basée sur celle de C\# mais il ne nécessite pas
d'environnement d'exécution. Vala est transformé en code C, lui-même
compilé en code machine natif. Les avantages d'une telle chaîne de
compilation sont de produire des logiciels qui requièrent moins de
mémoire vive et qui s'exécutent plus rapidement.

De plus, ce passage par l'étape C rend possible l'utilisation des
bibliothèques C au moyen d'interfaces définies dans les fichiers
Vapi. Des fichiers Vapi sont fournis avec Vala pour une grande partie
de la plateforme GNOME, ainsi que pour d'autres bibliothèques.

\section{Le format Flatpak}
% from: https://fr.wikipedia.org/wiki/Flatpak
Flatpak, nommé xdg-app jusqu’en mai 2016, est un système de
virtualisation d’application pour les distributions GNU/Linux de
bureau.

L'objectif est de fournir un environnement « bac à sable » (sandbox)
sûr, isolé du reste du système, dans lequel les utilisateurs peuvent
exécuter des applications non validées par les dépôts de la
distribution (des versions de test, par exemple). Les applications
utilisent des appels de fonctions spécifiques fournies par xdg-app
pour contrôler les périphériques matériels ou accéder aux fichiers de
l'utilisateur, et xdg-app demande à l'utilisateur sa permission avant
de donner accès.

Le nom originel vient de freedesktop.org, qui est souvent abrégé en «
xdg », cette structure ayant hébergé sur ses serveurs le projet
xdg-app. En mai 2016, le projet a été rebaptisé « Flatpak ».

En juin 2016, un certain nombre d'applications connues sont portées en
format Flatpak, comme MonoDevelop, GNOME Shell, Pitivi ou LibreOffice.

Les applications Flatpak se téléchargent sous forme d'un fichier qui
peut s’exécuter directement sur le système, de façon indépendante de
la distribution linux précise utilisée, sous réserve que le logiciel
Flatpak ait été préalablement installé sur cette distribution.

Pour permettre au « bac à sable » de fonctionner malgré son isolement
du système, il faut donc que les bibliothèques ou dépendances
indispensables à un logiciel soient embarquées avec lui au sein de son
paquet « Flatpak ». Ce système a pour inconvénient d'embarquer
potentiellement plusieurs fois la même bibliothèque (une par paquet
Flatpak), et donc de prendre plus de place. Il a par contre pour
avantage de ne pas déstabiliser un logiciel Flatpak lors d'une mise à
jour de dépendances ou de bibliothèques, puisque cette mise à jour ne
le concernera pas. Il est dès lors assez simple de faire cohabiter
plusieurs versions d'un même logiciel.

\section{Découverte du logiciel}
\subsection{Compilation}
Nous avons rencontrés de nombreux problèmes relatifs à la compilation,
cela étant en grande partie du à l'utilisation de librairies encore en
état de développement actif, ainsi qu'au système de configuration
``Meson'' qui est un remplacement de ``./configure''.

Ainsi il a été nécessaire de compiler certaines librairies, parmi
lesquelles\footnote{Nous avons utilisé Debian Sid comme OS de dévellopement et de test}:
\begin{itemize}
\item retro-gtk
\item libmanette
\end{itemize}

% Gautier : installation compliquée -> versionnage + aucun fichier d'installation
% + problème d'affichage : les jeux sont chargés avec de mauvaises images
% + problème configuration : on ne peut pas configurer les touches du clavier
%   dans les jeux
% + code pas commenté : possibilité de le commenter pour qu'il soit plus clair et
%   plus accessible

\section{Les bug reports}
% Gautier : système de statuts -> aucune explication
% Gautier : lecture de différents bug reports, et réécriture plus simple dans un
%           fichier partagé pour effectuer un premier tri
\subsection{Bug pulseaudio}
Un bug avec pulseaudio était declaré pour Games, en effet le programme crashait
quand le server pulseaudio était éteint et que l'on tentait de lancer
un jeu.

Le terminal retournait le message d'erreur suivant:
\begin{verbatim}
Assertion 'p' failed at pulse/simple.c:273, function pa_simple_write(). 
Aborting.
\end{verbatim}
Il a donc fallu reproduire le bug, pour cela nous avons personnalisés notre
configuration pulseaudio pour qu'il ne se relance pas automatiquement.
\begin{verbatim}
/etc/pulse/client.conf:
   autospawn = no
\end{verbatim}
Nous avons aussi utilisés une commande pour simuler le crash du server pulseaudio.
\begin{verbatim}
$ pulseaudio --kill
\end{verbatim}
% David: correction pas finie
A partir de là nous avons tracé le bug dans le code source. Le bug venait d'une
fonction de la bibliotheque pusleaudio qui reservais une structure ``null'' en
entrée et passait par un assert qui met donc fin au programme avec le message
évoqué présédement. Nous avons donc commencer à réflechire a une solution.
La solution la plus simple étais de contourné la fonction qui provoque le crash
avec un test de la valeur de la structure et un ``return'' prématuré dans la fonction
appellente si la valeur est ``null'' pour bypassé le crash. \newline
Nous avons aussi pen!cer a afficher un message a l'utilisateur et luis demandant
si il voulais lancer quand même le jeux mais sans le son. \newline
La premiere solution nous a parut trop simple et pas suffisament fiable, et la
second un trop compliquer a mettre en oeuvre sur un projet que l'on découvrais juste.
Nous avons donc désider de poster sur le rapport de bug notre analise du problème.
\newline
Finalement le mainteneur a opter pour la première solution et à
corriger le bug.

\section{Nos patchs}
% TODO PA: Cette partie a besion d'une relecture
\subsection{Mise à jour du fichier HACKING}
Le premier patch que nous avons envoyés, est en reponse à un bug report
(\href{http://bugzilla.gnome.org/show_bug.cgi?id=788692}{ici}), il ajoute une
aide pour la compilation du projet. \newline
Il n'y avait aucune aide ou information dans la documentation sur la compilation
du projet. Étant nouveaux dans le projet GNOME nous n'avions pas connaissance de 
GNOME-Builder qui permet assez simplement de construire le projet. Mais
même avec cet outil la compilation s'est revélée ardue. En effet 
le fonctionement de Builder a tendence à changer entre les versions et certaines
actions comme un ``git pull'' peuvent poser problème.
Nous avons donc modifié le fichier HACKING du projet pour y ajouter des 
instruction de compilation. \newline
Le projet utilise pour le moment le système ``autotools'' pour sa configuration et 
sa compilation, mais pour la version 2.30 il set prevue qu'il passe à un system
avec le logiciel ``meson'' pour la configuration. \newline
Nous avons donc nous même recontrés de nombreux problèmes de compilation,
il nous a donc semblé important de donner des indications pour que les 
prochaines personne qui voudrais contribuer ne sois pas freinées par un 
problème comme celui-ci.
Il y a eu de nombreux ajustements demandés par le mainteneur et le patch n'a 
pas encore étais aprouvé. \newline

\subsection{Mise à jour du fichier README.md}
Le second patch (\href{http://bugzilla.gnome.org/show_bug.cgi?id=790454}{ici}) 
que nous avons envoyés, est une mise à jour de la documentation de retro-gtk.
En effet retro-gtk est passé d'un système de compilation 'autotools' à un
système avec le logiciel 'meson' et le compilateur 'ninja'.
Nous avons donc mis à jour le fichier README.md en respectant la syntaxe
'Marckdown', utilisé par github et gitlab par exemple.
Le patch n'a pas encore été aprouvé. \newline

\subsection{Retour à la collection avec les touches Alt+Left}
Le but de ce patch est de lier un évent à une combinaison de touches
(en l'occurence Alt+Left).

La modification a consisté à modifier un fichier, celui se trouvait
dans le répertoire /src/ui et se nommait application-window.vala .

Une fonction permettant de retourner à la collection existait déjà:

\begin{minted}[breaklines]{vala}
private void on_display_back () {
  if (quit_game ())
  ui_state = UiState.COLLECTION;

  uninhibit (Gtk.ApplicationInhibitFlags.IDLE | Gtk.ApplicationInhibitFlags.LOGOUT);
}
\end{minted}

Une fonction qui liait l'appui de certaines touches à des événements
était aussi déjà présente:

\begin{minted}[breaklines]{vala}
  private bool handle_display_key_event (Gdk.EventKey event) {
    if (ui_state != UiState.DISPLAY)
    return false;

    var default_modifiers = Gtk.accelerator_get_default_mod_mask ();

    if ((event.keyval == Gdk.Key.f || event.keyval == Gdk.Key.F) &&
    (event.state & default_modifiers) == Gdk.ModifierType.CONTROL_MASK &&
    display_header_bar.can_fullscreen) {
      is_fullscreen = !is_fullscreen;
      settings.set_boolean ("fullscreen", is_fullscreen);

      return true;
    }

    if (event.keyval == Gdk.Key.F11 && display_header_bar.can_fullscreen) {
      is_fullscreen = !is_fullscreen;
      settings.set_boolean ("fullscreen", is_fullscreen);

      return true;
    }

    if (event.keyval == Gdk.Key.Escape && display_header_bar.can_fullscreen) {
      is_fullscreen = false;
      settings.set_boolean ("fullscreen", false);

      return true;
    }
    
    return false;
  }
\end{minted}

C'est en prenant cet extrait pour exemple que nous avons ajouté une
condition dédiée à Alt+Left, il nous a été necessaire de chercher dans
la documentation du langage Vala pour trouver la X (modifier key ?)
correspondante.

Voici le code correspondant à notre patch:

\begin{minted}[breaklines]{vala}
  if (event.keyval == Gdk.Key.Left){			
    on_display_back ();
    
    return true;
  }
\end{minted}

Puis en effectuant des tests, nous nous sommes rendus compte que la
condition validant l'appui sur la touche Alt n'était pas necessaire;
pourtant, le déclenchement de l'évent necessitait toujours un appui
physique sur Alt.

Par la suite, le mainteneur à décidé de réécrire le patch pour ajouter
la vérification de la pression sur la touche Alt:

\begin{minted}[breaklines]{vala}
  if (((event.state & default_modifiers) == Gdk.ModifierType.MOD1_MASK) &&
  (((get_direction () == Gtk.TextDirection.LTR) && event.keyval == Gdk.Key.Left) ||
  ((get_direction () == Gtk.TextDirection.RTL) && event.keyval == Gdk.Key.Right))) {
    on_display_back ();

    return true;
  }
\end{minted}




% Annexe:
\appendix
%% \chapter{GNOME en images}

%% \begin{figure}[p]
%%   % from: https://bugzilla.gnome.org
%%   \caption{\label{figure_bugzilla} Le bugzilla du projet GNOME}
%%   \includegraphics[width=15cm]{images/bugzilla_gnome_org.png}
%% \end{figure}

%% \begin{figure}[p]
%%   % from: https://bugzilla.gnome.org
%%   \caption{\label{figure_bugzilla_score} Score sur bugzilla}
%%   \includegraphics[width=5cm]{images/score.png}
%% \end{figure}

%% \begin{figure}[p]
%%   % from: https://wiki.gnome.org
%%   \caption{\label{figure_wiki} Le wiki du projet GNOME}
%%   \includegraphics[width=15cm]{images/wiki_gnome_org.png}
%% \end{figure}

%% \begin{figure}[p]
%%   % from: https://git.gnome.org
%%   \caption{\label{figure_cgit} Interface git du projet GNOME}
%%   \includegraphics[width=15cm]{images/git_gnome_org.png}
%% \end{figure}

%% \begin{figure}[p]
%%   % from: https://gitlab.gnome.org
%%   \caption{\label{figure_gitlab} Le gitlab du projet GNOME}
%%   \includegraphics[width=15cm]{images/gitlab_gnome_org.png}
%% \end{figure}

\chapter{Patchs} 
% PA: Utile ? 

\end{document}
